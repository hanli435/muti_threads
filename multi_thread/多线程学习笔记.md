C++高级编程
1.应用场景：在多处理器的计算机系统上，多线程编程非常重要。
2.多处理器单元系统
  2.1系统具有短歌处理器芯片，每个芯片都是一个独立的CPU（中央处理器）
  2.2心痛也可只有一个处理芯片，但该芯片内部由多个独立的CPU（也称为核心）组成
  2.3:上述二者的组合。
  
3.多线程编程概述
  3.1：争用条件
    3.1.1：当多个线程访问共享的内存，且至少有一个线程写入共享的内存时，就会发生数据争用。
  3.2：撕裂
     3.2.1定义：撕裂是数据争用的特例或结果。
     3.2.2类型
        3.2.2.1：撕裂度：如果线程已将数据的一部分写入内存，但还有部分数据没有写入，此时读取数据的其他任何线程将看到不一致的内容，发生撕裂读。
        3.2.2.1：撕裂写：如果两个线程同时写入数据，其中一个线程可能写入数据的一部分，而另一个线程可能写入数据的另一部分，最终结果将不一致，发生撕裂写。
  3.3死锁
      3.3.1：场景：如果选择使用互斥等同步方法解决争用条件的问题，那么可能遇到多线程中的死锁问题。
      3.3.2：定义：死锁指的是两个线程因为等待访问另一个阻塞线程锁定的资源而造成无线阻塞，这也可以扩展到超过两个线程的情形。
      3.3.3优化方法
          （不推荐使用）
        3.3.3.1：最好总是使用相同的顺序获得权限，以避免这种死锁。
        3.3.3.2：在程序中包含打破这种死锁的机制：如试图等待一定的时间，看看能否获得某个资源的权限。如果不能在某个时间间隔内获得这个权限，那么线程停止等待，并释放当前持有的其他锁。
          （推荐使用）
        3.3.3.3：如果需要获得有多个互斥对象保护的多个资源的权限，而非单独获取每个资源的权限，推荐使用标准的std::lock()或 std::try_lock()函数
        这两个函数会通过依次调用获得或尝试获得多个资源的权限。
  3.4伪共享
  
4线程
    4.1头文件：<thread>
    4.2线程执行内容：可通过多种方式指定新线程需要执行的内容。可让新线程执行全局函数、函数对象的operator()、lambda表达式是指某个类实例的成员函数。
       4.2.1：通过函数指针创建线程
          4.2.1.1：与相似函数的对比：windows上的CreatThread(),_beginthread()等函数，以及pthreads库中的pthread_create()函数，都要求线程函数只有一个参数。
          另一方面，标准C++的std::thread类使用的函数可以有任意数量的参数。
          4.2.1.2：线程创建：可通过std::thread启动执行函数的线程， thread t1(fun,paras,...),第一个参数为线程要执行的函数的名称。
          4.2.1.3：thread分析：thread类的构造函数是一个可变参数的模板，
          4.2.1.4:特点：如果一个线程表示系统当前或过去的某个活动线程，则认为他是可结合的。默认够早的线程对线是不可结合的。。
          在销毁一个可结合的线程对象前，必须调用其join()或detach()方法。
          join():阻塞调用，会一直等到线程执行完成工作为止。
          detach()：将线程对象与底层OS线程分离。此时，OS线程将继续独立运行。
          调用上述两种方法时，都会导致线程变得不可结合。
          如果一个仍可结合的线程对象被销毁，析构函数会调用std::terminate(),这会突然终止所有线程及应用程序自身。
